## 계층형 설계(Stratified Design)
바로 아래 계층의 함수로 지금 계층의 함수를 만드는 방법
- 코드를 추상화 계층으로 구성
- 각 계층을 볼 때, 다른 계층의 구체적인 내용을 몰라도 되도록

Mega Mart 예시
- 비즈니스 로직
  - gets_free_shipping(), calcTax()
- 장바구니를 위한 동작들
  - 이커머스 도메인에서 자주 쓰이는 함수들
  - remove_item_by_name(), calc_total()
- 카피 온 라이트
  - removeItems(), add_element_last()
- 프로그래밍 언어
  - slice()

## 패턴 1: 직접 구현
함수를 명확하고 아름답게 구현해 계층을 구성하기 위함
- 한 함수에서 서로 다른 계층의 함수가 혼재하면 코드가 명확하지 않아서 가독성이 떨어짐
- 예제 `megaMart.ts`의 freeTieClip 함수 확인

## 패턴 2: 추상화 벽
추상화 벽(abstraction barrier)
- 세부 구현을 감춘 함수로 이루어진 계층
- 추상화 벽에 있는 함수를 사용할 때는 구현을 전혀 몰라도 함수를 쓸 수 있음
  - 예) 마케팅팀에서 추상화 벽에 있는 무료 배송비 함수(gets_free_shipping()를 자유롭게 사용
  - 예) 개발팀에서는 추상화 벽에 있는 함수가 어떻게 쓰이든 신경쓰지 않아도 됨
- 외부 라이브러리나 API와 비슷

## 패턴 3: 작은 인터페이스
작은 인터페이스(minimal interface)
- 상위 계층에 어떤 함수를 만들 때, 가능한 현재 계층에 있는 함수로 구현
  - 하위 계층에 기능을 추가하는 것보다 비교적 상위 계층에 구현
- 인터페이스를 최소화하여 하위 계층에 불필요한 기능이 커지는 것을 막을 수 있다

## 패턴 4: 편리한 계층
편리한 계층(comfortable layer)
- 계층형 설계 패턴과 실천 방법은 개발자의 요구를 만족시키면서도 비즈니스 문제를 잘 풀 수 있어야 함
- 실용성(개발 생산성)을 위해 더 좋은 설계를 고민하는 것을 멈추기
- 거대하고 강력한 추상화 계층을 설계하는 것은 리소스가 많이 들기 때문

### 가장 높은 계층에 있는 코드
유지보수성 좋음
- 쉽게 바꿀 수 있다
  - 가장 위에 있는 함수는 아무 곳에서도 호출하는 곳이 없기 때문
- 자주 바뀌는 코드를 배치

테스트 용이성 낮음
- 테스트해서 얻을 수 있는 것이 적음
- 테스트 코드를 오래 쓰지 못함

재사용성 낮음

### 가장 낮은 계층에 있는 코드
유지보수성 낮음
- 고치기 어렵다
  - 다른 상위 동작들도 바뀌어야 함
- 거의 바뀌지 않는 코드를 배치
  - 예) COW 함수

테스트 용이성 좋음
- 테스트 코드를 오래 쓸 수 있음
- 의존하고 있는 함수들이 많아서 테스트가 중요

재사용성 좋음
- 낮은 수준의 단계로 함수를 빼낼수록 재사용성이 높아짐