## ch6. 변경 가능한 데이터 구조를 가진 언어에서 불변성 유지하기
### copy-on-write 정말 성능에 문제 없을까?
불변 데이터 구조는 빠르다 (바뀔 때마다 복사해서 느리다고 생각할 수 있지만)
- 가비지 콜렉터가 매우 빠르게 동작
- 생각보다 많이 복사하지 않음 (대부분 얕은 복사)
  - 얕은 복사(shallow copy): 중첩된 데이터 구조의 최상위 데이터만 복사
  - 예) 객체로 이루어진 배열 -> 배열만 복사되고 객체는 참조로 공유됨 (객체들은 같은 메모리 주소)
  - 아래의 구조적 공유 참고!
- 만약에 느려지면 그때 가서 최적화하면 됨

### 구조적 공유(structural sharing)
중첩된 데이터 구조에서 안쪽 데이터가 같은 데이터를 참조
- 예시
```
메모리주소: <>로 표현
<1>      <2>         <3>        <4>
a = [{ 객체1 }, { 객체2 }, { 객체3 }]

// 배열의 얕은 복사 (slice())
<5>      <2>         <3>        <4>
a` = [{ 객체1 }, { 객체2 }, { 객체3 }]

// 객체3의 얕은 복사 (Object.assign()) 및 프로퍼티 수정
<5>      <2>         <3>        <6>
a` = [{ 객체1 }, { 객체2 }, { 객체3` }]
```

## ch7. 신뢰할 수 없는 코드를 쓰면서 불변성 지키기
### COW와 방어적 복사 중 중요도를 굳이 따지자면?
안전지대 측면에서
- 애플리케이션에 안전지대만 있을 수는 없다
- 외부(다른 라이브러리, 기존 레거시 코드)와 교류할 일이 반드시 존재
- 두 패턴을 모두 적절하게 사용하는 것이 좋다