# ch7. 신뢰할 수 없는 코드를 쓰면서 불변성 지키기

## 코드 보호를 위해 방어적 복사 만들기
기존의 COW 적용 코드에 레거시 코드의 함수를 사용해야 할 때
- 추가된 함수를 사용하면 COW 패턴에 어긋남
- 방어적 복사를 활용하여 COW 패턴을 지키며 외부의 함수 사용 가능


### 방어적 복사(Defensive Copy)
- 데이터를 변경할 수도 있는 코드와 불변성 코드 사이에 데이터를 주고받을 때, 데이터의 깊은 복사본을 만들어 전달
- 원본이 바뀌는 것을 막아줌

규칙 1.데이터가 안전한 코드에서 나갈 때 복사하기
- 변경 불가능한 데이터가 신뢰할 수 없는(불변성을 훼손할 수 있는) 코드로 나갈 때

1. 불변성 데이터 깊은 복사
2. 신뢰할 수 없는 코드로 깊은 복사본 전달

규칙 2.안전한 코드로 데이터가 들어올 때 복사하기
- 신뢰할 수 없는 코드에서 변경될 수도 있는 데이터가 들어올 때

1. 변경될 수도 있는 데이터 깊은 복사
2. 복사본을 안전한 코드에서 사용

`megaMart.ts` 에서 예제 확인

### 방어적 복사 패턴을 사용하는 예시
웹 API 요청과 응답에 사용되는 JSON
- 클라이언트, 서버 모두 데이터를 JSON으로 직렬화하면서 깊은 복사본 전달
- 서로 다른 서비스들 간에 문제없이 통신하기 위해서 방어적 복사 사용
  - 예) MSA, 서비스 지향 시스템 등

얼랭(Erlang), 엘릭서(Elixir) 프로그래밍 언어
- 두 함수형 프로그래밍 언어 모두 방어적 복사가 구현되어 있음
- 프로세스 간 메시지 주고 받을 때 깊은 복사를 사용하여 고가용성 보장

### 동시에 깊은 복사본이 2개 생길 때 어느 것이 진짜일까?
함수형 프로그래밍에서 유일한 객체를 찾는 의미가 없음
- 데이터: 이벤트에 대한 사실일 뿐
- 예) 대부분의 소프트웨어에서 User 객체를 사용하지만, 함수형 프로그래밍에서는 어떤 이벤트에 대한 사실로 간주

## 얕은 복사와 깊은 복사 비교
- 깊은 복사(deep copy)는 중첩된 데이터 전체를 복사, 얕은 복사(shallow copy)는 필요한 부분만 최소한으로 복사

<table>
  <caption><i>copy-on-write</i> 와 <i>방어적 복사</i> 비교</caption>
  <thead>
    <tr>
      <th></th>
      <th>copy-on-write</th>
      <th>방어적 복사</th>
    </tr>
    <tr>
      <th>사용 시점</th>
      <td>통제할 수 있는 데이터를 바꿀 때</td>
      <td>신뢰할 수 없는 코드와 데이터를 주고 받을 때</td>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>사용 장소</th>
      <td>안전지대(불변적 데이터가 사용되는 공간)</td>
      <td>안전지대의 경계</td>
    </tr>
    <tr>
      <th>복사 방식</th>
      <td>얕은 복사(비용 적음)</td>
      <td>깊은 복사(비용 큼)</td>
    </tr>
    <tr>
      <th>규칙</th>
      <td>1. 바꿀 데이터의 얕은 복사 만듬<br/>2. 복사본을 변경<br/>3. 복사본을 리턴</td>
      <td>1. 안전지대로 들어오는 데이터에 깊은 복사 만듬<br/>2. 안전지대에서 나가는 데이터에 깊은 복사 만듬</td>
    </tr>
  </tbody>
</table>

### JS에서 깊은 복사 구현
lodash 라이브러리 사용을 권장
- JS에서 깊은 복사를 구현하기 어려움 (빌트인 객체에서 구현 안되어 있음)
- 대개 lodash 라이브러리의 cloneDeep() 함수를 사용하여 깊은 복사 기능 활용
- 제한적인 구현: `sampleDeepCopy.js` 확인

## COW와 방어적 복사 중 중요도를 굳이 따지자면?
안전지대 측면에서
- 애플리케이션에 안전지대만 있을 수는 없다
- 외부(다른 라이브러리, 기존 레거시 코드)와 교류할 일이 반드시 존재
- 두 패턴을 모두 적절하게 사용하는 것이 좋음