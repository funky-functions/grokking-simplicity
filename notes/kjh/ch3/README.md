# ch3. 액션과 계산, 데이터의 차이를 알기

## 1. 장보기 과정을 바탕으로 액션, 계산, 데이터 구분하기

### 액션
- 실행 시점과 횟수에 의존
- 사이드 이펙트, 사이드 이펙트가 있는 함수, 비순수 함수 라고도 함
- 예) 이메일 보내기, 데이터베이스 읽기

### 계산
- 입력으로 출력을 계산
- 순수 함수, 수학 함수라고도 함
- 예) 최댓값 찾기, 이메일 주소 유효성 검증

참조 투명(referentially transparent)
- `2 + 3` 코드에서 `+`는 계산이기 때문에 `2 + 3`의 결과는 항상 `5`
- `2 + 3` 코드를 `5`라는 결과값으로 바꿔도 프로그램이 달라지지 않음

### 데이터
- 이벤트에 대한 사실
- 예) 유저가 입력한 이메일 주소

### 액션, 계산, 데이터 구분
모든 개발 과정에서 액션, 계산, 데이터를 구분할 수 있다
- 개발 전: 문제 정의 과정
  - 꼭 액션으로 처리해야 하는지?, 데이터로 처리할 수는 없는지
- 개발 중
  - 최대한 액션에서 계산 뽑아냄
  - 계산에서 데이터를 분리하려고 노력
- 개발 후
  - 숨은 액션 찾고 리팩토링

### 장보기 과정에서 액션, 계산, 데이터 구분
장보기 과정 (1차)
- 냉장고 확인: 액션
  - 냉장고(DB) 데이터가 언제 바뀔지 모르기 때문에 액션
- 운전해서 상점으로 가기: 액션
- 장보기 목록대로 구입하기: 액션
- 운전해서 집으로 오기: 액션
- 음식을 냉장고에 보관하기: 액션

장보기 과정 (2차: 상세 분류)
- 냉장고 확인: 액션
  - 냉장고 현재 재고: 데이터
- 운전해서 상점으로 가기: 액션
- 장보기 목록대로 구입하기
  - 장보기 목록: 데이터 (필요한 재고에서 냉장고 현재 재고 뺀 결과)
  - 필요한 재고: 데이터
  - 빼기: 계산(입력 데이터 2개 필요)
  - 목록에 있는 것 구입: 액션
- 운전해서 집으로 오기: 액션
- 음식을 냉장고에 보관하기: 액션

이처럼 함수형 프로그래밍에서는 가급적 상세히 나누는 것이 중요
- 데이터를 먼저 찾으면 힌트를 얻기 쉬움

## 2. 쿠폰 마케팅 프로그램에 함수형 사고 적용하기

### 쿠폰 마케팅 프로그램
DB 예시

<table>
  <caption>구독자 DB 테이블</caption>
  <thead>
    <tr>
      <th>email</th>
      <th>rec_count</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>john@naver.com</td>
      <td>2</td>
    </tr>
    <tr>
      <td>park@naver.com</td>
      <td>16</td>
    </tr>
  </tbody>
</table>

<table>
  <caption>쿠폰 DB 테이블</caption>
  <thead>
    <tr>
      <th>coupon</th>
      <th>rank</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>10PERCENT</td>
      <td>bad</td>
    </tr>
    <tr>
      <td>20PERCENT</td>
      <td>good</td>
    </tr>
    <tr>
      <td>50PERCENT</td>
      <td>best</td>
    </tr>
  </tbody>
</table>

조건
- 10명 이상의 친구에게 추천한 구독자에게 best 쿠폰, 나머지에게는 good 쿠폰 보내주기

### 프로그램 흐름
- DB에서 구독자 리스트 쿼리: A
  - 구독자 리스트: D
- DB에서 쿠폰 리스트 쿼리: A
  - 쿠폰 리스트: D
- 보낼 이메일 리스트 만들기: C
  - 이메일 리스트: D
- 이메일 리스트대로 각각 쿠폰 전송: A

### 보낼 이메일 리스트 만들기 세분화
이메일 리스트 만들기 계산
- 보낼 이메일 리스트를 만들기 위해 구독자 리스트, 쿠폰 리스트 2개의 입력값 필요
- 계산 결과: 이메일 리스트

이메일 리스트 만들기 세분화
- best 쿠폰 이메일 리스트 만들기: C
  - 쿠폰 리스트(D)에서 best 쿠폰 선택하기: C
    - best 쿠폰 리스트: D1
  - 구독자 리스트에서 rec_count >= 10인 구독자 선택하기: C
    - rec_count >= 10인 구독자 리스트 : D2
- good 쿠폰 이메일 리스트 만들기: C
  - 쿠폰 리스트(D)에서 good 쿠폰 선택하기: C
    - good 쿠폰 리스트: D3
  - 구독자 리스트에서 rec_count < 10인 구독자 선택하기: 
    - rec_count < 10인 구독자 리스트 : D4
- D1, D2, D3, D4 데이터들을 바탕으로 이메일 리스트 반환

세분화하는 것의 장점: 액션에 비해 계산은 테스트하기 쉬움

### 쿠폰 보내는 과정 구현
- 쿠폰 등급이 good이면 good 이메일 만들기
- 쿠폰 등급이 best이면 best 이메일 만들기
- `coupon.ts` 확인

구현 순서
- 데이터 -> 계산 -> 액션

이메일을 보내기 전에 미리 모든 이메일 목록을 만들었음
- 그러나, 구독자가 수백만명이면, 이메일 목록의 길이도 수백만 개가 되고, 이는 메모리를 어마어마하게 잡아먹을 수 있음
- 실행하기 전에는 아직 모르기 때문에 미리 최적화할 필요가 전혀 없지만...
- 확장성을 고려하여 이메일 발송 코드를 미리 변경할 수 있음
- 변경 방향: DB에서 한 번에 모든 구독자 목록을 가져오지 않고, 20개씩 끊어서 가져오기
  - 함수형 프로그래밍을 잘 적용했다면, 계산은 건드리지 않고 액션만 고침

### 계산 자세히 알아보기
계산이 액션보다 좋은 이유
- 테스트 용이
- 정적 분석 쉬움 -> 자동화 테스트 용이?
- 조합해서 더 큰 계산을 만들 수 있음

## 3. 이미 있는 코드에 함수형 사고 적용하기
### 액션은 코드 전체로 퍼져 나간다
송금 함수가 있다고 가정하면..
- 횟수가 중요하기 때문에 액션에 해당
- 이 함수를 호출하는 모든 함수가 액션이 됨
  - 액션을 호출하는 모든 함수는 액션

### 액션 예시
- 함수 호출: 예) `alert("Hello world")`
- 메서드 호출: 예) `console.log("Hello world")`
- 생성자: 예) `new Date()`
  - 호출하는 시점에 따라 각기 다른 값을 가짐
- 표현식
  - 읽는 시점에 따라 값이 달라질 수 있음
  - 변수 참조: 예) `y`
  - 속성 참조: `user.first_name`
  - 배열 참조: `stack[0]`
- 상태
  - 값 할당: 예) `x = 3` -> 값 할당 이후의 다른 코드에 영향을 줌
  - 프로퍼티 제거: 예) delete user.first_name -> 제거 이후의 다른 코드에 영향을 줌

### 액션 사용시 권장 사항
1.가능한 액션 적게 사용

2.액션을 가능한 작게 만들기

3.액션이 외부 세계와 상호작용 하는 것을 제한
- 내부에는 데이터와 계산만 있고,
- 가장 바깥 쪽에만 액션이 있는 구조가 제일 이상적

4.액션이 호출 시점에 의존하는 것을 제한
- 호출 시점과 횟수에 덜 의존하게 만들기

## 4. 정리
계산, 데이터, 액션
- 계산: 계획하거나 결정
- 데이터: 계산의 결과(계획하거나 결정한 것)
- 액션: 계산으로 만든 계획을 실행