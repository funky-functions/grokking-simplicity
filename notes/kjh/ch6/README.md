# ch6. 변경 가능한 데이터 구조를 가진 언어에서 불변성 유지하기

## 불변성을 위해 copy-on-write 적용

### 동작을 읽기, 쓰기 또는 둘 다로 구분하기
읽기(read)
- 데이터를 바꾸지 않고 정보만 꺼내는 것
- 인자에만 의존해 정보를 가져오는 읽기 동작은 계산이라고 할 수 있음 

쓰기(write)
- 데이터 변경
- 데이터 변경이 예상치 못한 결과를 초래할 수 있으므로 불변성 원칙(copy-on-write)에 따라 구현해야 함

불변성을 유지하는 COW(copy-on-write) 원칙 3단계
1. 복사본 만들기
2. 복사본 변경하기(원하는 만큼)
3. 복사본 리턴하기

COW 구현 예제
```ts
function add_element_last(array: any[], elem: any) {
  // 배열 복사 (기존 배열을 변경하지 않음)
  // 복사한 배열은 함수 스코프 내부에 있기 때문에 다른 곳에서 접근 불가
  const new_array = array.slice();
  // 복사본 변경
  new_array.push(elem);
  // 복사본 리턴
  return new_array;
}
```

구현 결과
- COW는 쓰기를 읽기로 바꿈
- 데이터를 바꾸지 않으면서 필요한 데이터를 리턴했기 때문에 `읽기`에 해당

### COW로 쓰기를 읽기로 바꾸기
- `megaMart.ts` 리팩토링 1번 확인

### 재사용 가능하게 바꾸기
splice() 메서드 일반화해보기
- `megaMart.ts` 리팩토링 2번 확인

### 쓰기도 하면서 읽기도 하는 동작에 COW 적용하기
shift()
- 원본 배열의 맨 앞 원소 제거 (쓰기)
- 제거되는 맨 앞 원소를 반환 (읽기)

2가지 접근 방법
1. 읽기와 쓰기 함수로 각각 분리 (책임이 분리되어 더 좋음)
2. 함수에서 값을 2개 리턴

`copy-on-write.ts` 확인

copy on write를 적용하면 읽기가 되는 이유
- 원본을 바꾸지 않기 때문

### 불변 데이터와 계산, 액션
계산
- 불변 데이터 구조 읽기는 계산에 해당
- 쓰기를 읽기로 바꾸면 코드에서 계산 비율을 높일 수 있음

액션
- 변경 가능한 데이터 읽기 (변경 가능한 값 읽을 때마다 다른 값을 읽을 수 있어서)
- 쓰기는 데이터를 바꾸기 때문에 데이터를 변경 가능한 구조로 만듬
  - 어떤 데이터 구조에 쓰기가 없다면 불변 데이터 (생성 후 바꿀 수 없음)

COW는 데이터를 불변형으로 유지할 수 있게 해준다
- 변경 전 얕은 복사를 수행하고 리턴하여 불변성 유지

불변 데이터 구조는 빠르다 (바뀔 때마다 복사해서 느리다고 생각할 수 있지만)
- 가비지 콜렉터가 매우 빠르게 동작
- 생각보다 많이 복사하지 않음 (대부분 얕은 복사)
  - 얕은 복사(shallow copy): 중첩된 데이터 구조의 최상위 데이터만 복사
  - 예) 객체로 이루어진 배열 -> 배열만 복사되고 객체는 참조로 공유됨 (객체들은 같은 메모리 주소)
- 만약에 느려지면 그때 가서 최적화하면 됨

## 배열과 객체 데이터에 쓸 수 있는 copy-on-write 동작 만들기

### 객체에 대한 COW
복사본 만들기
- 객체에 slice()를 사용할 수 없으므로, Object.assign() 메서드를 사용하여 복사한다
- 예) `copy-on-write.ts`의 setPrice 함수

## 깊이 중첩된 데이터에 copy-on-write 잘 동작하게 만들기

### 중첩된 쓰기를 읽기로 바꾸기
객체로 이루어진 배열의 쓰기 동작을 COW로 바꾸기
- 중첩된 모든 데이터 구조의 모든 부분이 불변형이어야 함!
- 따라서 변경하려는 값과 상위의 모든 값 복사 필요
- 예) `copy-on-write.ts`의 setPriceByName 함수

### 구조적 공유(structural sharing)
중첩된 데이터 구조에서 안쪽 데이터가 같은 데이터를 참조
- 예시
```
메모리주소: <>로 표현
<1>      <2>         <3>        <4>
a = [{ 객체1 }, { 객체2 }, { 객체3 }]

// 배열의 얕은 복사 (slice())
<5>      <2>         <3>        <4>
a` = [{ 객체1 }, { 객체2 }, { 객체3 }]

// 객체3의 얕은 복사 (Object.assign()) 및 프로퍼티 수정
<5>      <2>         <3>        <6>
a` = [{ 객체1 }, { 객체2 }, { 객체3` }]
```
