# ch9. 계층형 설계

## 코드를 모듈화하기 위해 추상화 벽 만들기

### 계층형 설계 패턴
1. 직접 구현
2. 추상화 벽
3. 작은 인터페이스
4. 편리한 계층

## 패턴 2: 추상화 벽
추상화 벽(abstraction barrier)
- 세부 구현을 감춘 함수로 이루어진 계층
- 추상화 벽에 있는 함수를 사용할 때는 구현을 전혀 몰라도 함수를 쓸 수 있음
  - 예) 마케팅팀에서 추상화 벽에 있는 무료 배송비 함수(gets_free_shipping()를 자유롭게 사용
  - 예) 개발팀에서는 추상화 벽에 있는 함수가 어떻게 쓰이든 신경쓰지 않아도 됨
- 외부 라이브러리나 API와 비슷

### 추상화 벽을 사용하기 좋을 때
1.쉽게 구현을 바꾸기 위해
- 추후 구현이 바뀔 것이라 예상될 때
- 만약을 대비해 지금 불필요한 코드를 작성하는 것은 비효율적임을 명심하며 사용

2.코드를 읽고 쓰기 쉽게 만들기 위해
- 세부사항을 신경쓰지 않고 쉽게 코드를 만들 수 있음
- 때로는 너무 구체적인 것이 버그를 만듬

3.팀 간에 조율해야 할 것을 줄이기 위해
- 각 팀이 서로 구체적인 내용을 서로 신경쓰지 않고 일할 수 있음
- 팀 간 커뮤니케이션 비용 감소

4.주어진 문제에 집중하기 위해
- 해결하려는 문제의 본질에 집중할 수 있음 (세부사항은 무시)

### 추상화 벽 테스팅

## 패턴 3: 작은 인터페이스
작은 인터페이스(minimal interface)
- 상위 계층에 어떤 함수를 만들 때, 가능한 현재 계층에 있는 함수로 구현
  - 하위 계층에 기능을 추가하는 것보다 비교적 상위 계층에 구현
- 인터페이스를 최소화하여 하위 계층에 불필요한 기능이 커지는 것을 막을 수 있다

예시) 장바구니에 제품을 많이 담은 사람이 시계 구입할 때 10% 할인해주는 로직
```
if (장바구니 총합 > $100) && (장바구니에 시계가 있으면)
then 시계 10% 할인
```
- 마케팅팀에서 사용하기 위해 추상화벽 아래에 구현할 수는 없다

방법1. 추상화 벽에 함수 만들기
- 해시맵 데이터 구조로 되어 있는 장바구니에 접근 가능
- 같은 계층에 있는 함수 사용 불가
  - 예)
  - `추상화 벽 위` -> gets_free_shipping(), calcTax(), ...
  - `추상화 벽` -> getsWatchDiscount(), calc_total(), ...
```js
function getsWatchDiscount(cart) {
  let total = 0;
  const names = Object.keys(cart);
  for(let i = 0; i < names.length; i++) {
    const item = cart[names[i]];
    total += item.price;
  }
  return total > 100 && cart.hasOwnProperty("watch");
}
```

방법2. 추상화 벽 위에 함수 만들기
- 해시맵 데이터 구조로 되어 있는 장바구니에 접근 불가
  - 같은 추상화 벽에 있는 함수로 장바구니에 접근해야 함
- 아래 계층인 추상화 벽에 있는 함수 사용 가능
```js
function getsWatchDiscount(cart) {
  const total = calcTotal(cart); // 추상화 벽에 있는 함수
  const hasWatch = isInCart("watch");
  return total > 100 && hasWatch;
}
```

### 추상화 벽 위의 계층에 구현하는 것이 더 좋은 이유
방법2번이 직접 구현 방식에 더 가깝다
- 시스템 하위 계층 코드가 늘어나는 것은 좋지 않음
- 마케팅팀을 위한 코드이므로 JS 레벨의 for loop로 함수를 만드는 것은 가독성에 좋지 않음
  - 함수 수정이 필요할 때 마케팅팀에서 수정 불가

### 추상화 벽을 작게 만들어야 하는 이유
1. 추상화 벽에 코드가 많을 수록 구현이 변경되었을 때 고쳐야 할 것이 많다
2. 추상화 벽에 있는 코드는 낮은 수준의 코드이기 때문에 버그가 더 많을 수 있다
3. 낮은 수준의 코드는 이해하기 더 어렵다
4. 추상화 벽에 코드가 많을 수록 팀 간 조율할 것이 많아진다
5. 추상화 벽에 인터페이스가 많으면 알아야 할 것이 많아 사용하기 어려워진다

## 패턴 4: 편리한 계층
편리한 계층(comfortable layer)
- 계층형 설계 패턴과 실천 방법은 개발자의 요구를 만족시키면서도 비즈니스 문제를 잘 풀 수 있어야 함
- 실용성(개발 생산성)을 위해 더 좋은 설계를 고민하는 것을 멈추기
- 거대하고 강력한 추상화 계층을 설계하는 것은 리소스가 많이 들기 때문

## 왜 계층형 설계가 유지보수와 테스트, 재사용에 도움이 되는지 이해하기

### 가장 높은 계층에 있는 코드
유지보수성 좋음
- 쉽게 바꿀 수 있다
  - 가장 위에 있는 함수는 아무 곳에서도 호출하는 곳이 없기 때문
- 자주 바뀌는 코드를 배치

테스트 용이성 낮음
- 테스트해서 얻을 수 있는 것이 적음
- 테스트 코드를 오래 쓰지 못함

재사용성 낮음

### 가장 낮은 계층에 있는 코드
유지보수성 낮음
- 고치기 어렵다
  - 다른 상위 동작들도 바뀌어야 함
- 거의 바뀌지 않는 코드를 배치
  - 예) COW 함수

테스트 용이성 좋음
  - 테스트 코드를 오래 쓸 수 있음
  - 의존하고 있는 함수들이 많아서 테스트가 중요

재사용성 좋음
- 낮은 수준의 단계로 함수를 빼낼수록 재사용성이 높아짐